# Shell基础

## history（历史命令）
`history`命令可以展示我们执行过的命令。执行过的命令，在正常退出终端的时候，都会报错在`/root/.bash_history`文件中。在退出终端前，执行过的命令在内存里面。

环境变量`$HISTSIZE`定义了`.bash_history`可以保存多少条历史命令。在`/etc/profile`文件里可以修改$HISTSIZE的值：
```
$ vim /etc/profile
HISTSIZE=1000           # 1000是默认值，修改数字即可
HISTTIMEFORMAT="%Y/%m/%d %H:%M:%S "     # 添加此条可显示命令执行时间

$ source /etc/profile   # 执行生效

$ chattr +a ~/.bash_history  # 防止被意外删除
```
终端操作：
- `history -c`：清除当前历史命令
- `!!`：执行上一条命令
- `!n`：执行`.bash_history`文件中的第n条命令
- `!word`：执行`.bash_history`文件中最近一次以word开头的命令
---
## 命令补全及别名
命令补全：终端输入命令或文件时，按`tab`键一下可以补全。按`tab`键两下可以列出当前关键字开头的所有命令或文件。

Centos7支持命令参数自动补全。需要安装`bash-completion`包：
```
$ yum install -y bash-completion
```

### 别名：
```
# 查看当前所有的别名
$ alias

# 新建别名。别名保存在/etc/profile.d/目录下和当前用户的.bashrc文件中。用户自定义的别名都保存在.bashrc文件中
$ alias lf='ls -a'      # 临时别名
$ vim ~/.bashrc         # 永久别名
alias lf='ls -a'

# 取消自定义别名
$ unalias lf
```
---
## 通配符
- `*`：匹配任意字符  
- `?`：匹配任意单个字符  
- `[]`：匹配任意个括号中的字符或数字，可以在中括号加入`0-9` `a-z` `A-Z`，例如：`ls [ao]*`表示以a和o开头的所有文件；`ls [1-3].txt`表示1.txt 2.txt 3.txt。
- `[!]`：不匹配中括号中的字符或数字，例如：`ls [!0-9]*`表示不以数字开头的文件  
- `{}`：匹配花括号中的任意个或范围的字符或数字，例如：
> ```
> $ ls {a,b,c}.txt        # 匹配a.txt b.txt c.txt
> $ ls {lwz,zc}.txt       # 匹配lwz.txt zc.txt
> $ touch {a..f}.txt      # 创建a到f这个范围的.txt文件
> ```

## 特殊符号
- `#`：在终端输入命令时，命令行提示符`#`后面的符号是当前用户是root用户，例如：`# ls`；在文件中，`#`代表注释。
- `\`：转义符；将特殊符号，转义成普通符号。
- `$`：在终端输入命令时，命令行提示符`$`后面的符号就是当前用户，例如：`$ ls`；也是shell中变量的前缀。
- `!$`：在正则表达式中表示行尾；在终端输入命令时，表示把上一条命令的参数作为标准输出，例如：
    - ```
        $ ls aa.txt
        aa.txt
        $ !ls
        ls aa.txt
        aa.txt
        或者
        $ ls !$
        ls aa.txt
        aa.txt
        ```
- `~`：在终端时表示用户的家目录；在正则表达式中表示匹配符。

## 输入、输出、重定向
- `0`：标准输入，从键盘输入
- `1`：标准输出，输出到终端
- `2`：标准错误，输出到终端
<br/>

- `>`：输出重定向，将命令执行的结果输出到文件中，如果文件存在，则覆盖，如果不存在，则创建。  
- `>>`：输出重定向，将命令执行的结果追加到文件中，如果文件存在，则追加，如果不存在，则创建。
- `2>`：标准错误，将命令执行过程中的错误信息覆盖到文件中，正确结果不输入。
- `2>>`：标准错误，将命令执行过程中的错误信息追加到文件中，正确结果不输入。
- `&>`：标准输出和标准错误都覆盖到文件中。
- `&>>`：标准输出和标准错误都追加到文件中。
- `<`：输入重定向，将文件中的内容作为命令的输入。

## 管道和任务控制
示例：`cat 11.txt | wc -l;cat 11.txt|grep 'pass'`
- `wc -l`：统计文件内容的行数或者文件的数量。
<br/>
管道：

- `|`：管道，将一个命令的输出作为另一个命令的输入。
- `;`：任务分隔，多个任务依次执行。

- `&&`：逻辑与，当第一个命令执行成功后，才执行第二个命令。
- `||`：逻辑或，当第一个命令执行失败后，才执行第二个命令。
<br>
任务控制：

- `&`：后台运行，将任务放到后台执行。在命令结尾加上`&`符号，如：`ping 127.0.0.1 &`，后台运行`ping`命令。
- `ctrl + z`：将任务放到后台，并暂停执行。（后台可以暂停多个任务）
- `jobs`：查看当前后台任务。
- `fg [id]`：将任务放到前台，并继续执行。
- `bg [id]`：将暂停的任务放到后台，并继续执行。
- `sleep`：延迟执行任务。默认以秒(s)为单位
    - 示例：`sleep 10s;ls`  # 10秒后执行`ls`命令
    - `s`为秒，`m`为分，`h`为小时，`d`为天
- `kill [id]`：结束任务，`id`为任务编号。


----
## Shell变量

### 变量类型
- 局部变量：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
- 环境变量：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
- shell变量：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行。

#### 环境变量配置文件
- `/etc/profile`：系统级，定义系统全局环境变量，该文件中定义的环境变量会在用户登陆时被加载。
- `/etc/bashrc`：系统级，但它仅对bash shell生效。当用户启动一个新交互式bash shell时，该文件会被读取，并设置bash shell特定的环境变量和执行一些系统级的初始化操作。
- `~/.bashrc`：用户级，用户的个人配置文件，该文件中的环境变量会在用户启动新的终端窗口时被加载。
- `~/.bash_profile`：用户级，该文件是每个用户的个人配置文件，该文件中定义的环境变量仅在该用户登陆时有效。

### 定义变量
```
name="lwz"      # 定义一个变量，变量名为name，变量值为lwz
```
> 注：变量名和等号之间不能有空格。同时，变量名的命名须遵循如下规则：
> - 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。
> - 中间不能有空格，可以使用下划线`_`。
> - 不能使用标点符号。
> - 不能使用bash里的关键字(可用`help`命令查看保留关键字)。

用语句给变量赋值：
```
# 将/etc目录下的文件
for file in `ls /etc`
或者
for file in $(ls /etc)
```

#### 单引号
```
$ myname='my name is lwz'
```  
单引号字符串的限制：
- 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的。
- 单引号字符串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可以成对出现，作为字符串拼接使用。

#### 双引号
```
$ name="lwz"
$ myname="my name is \"$name\" !"   # \为转义符，双引号中的双引号作用为拼接，转义后为普通双引号输出。
$ echo $myname
my name is "lwz" !
```
- 双引号里可以用变量。
- 双引号里可以出现转义字符。

#### 反引号
反引号` `` `，反引号中的内容会当做一个命令来执行，并且将执行结果作为变量的值。
```
# 将当前时间作为变量的值赋值给a。
$ a=`date`
$ echo $a
Wed Feb 26 16:37:15 CST 2019
```

#### 拼接字符串
```
$ name="lwz"

# 双引号拼接
$ myname="myname: my name is "$name" !"
$ myname1="myname1: my name is ${name} !"
$ echo $myname $myname1
myname: my name is lwz ! myname1: my name is lwz !

# 单引号拼接
$ myname2='myname2: my name is '$name' !'
$ myname3='myname3: my name is ${name} !'
$ echo $myname2 $myname3
myname2: my name is lwz ! myname3: my name is ${name} !
```

### 使用变量
变量名前面加上美元符号`$`即可。
```
$ echo $name
或者
$ echo ${name}
```
> 变量名外的花括号`{}`是可选的，建议加上，避免歧义，类似如下情况。
> ```
> $ echo ${name}123
> lwz123
> ```

### 只读变量
使用`readonly`命令将变量定义为只读变量，只读变量的值不能被更改。
```
# 将变量"name"设置成只读变量
$ readonly name
$ name="qqq"
-bash: name: readonly variable
```
> 注意：设置为只读变量，有可能无法删除。

### 删除变量
```
# 使用unset命令删除变量
$ unset name
```

